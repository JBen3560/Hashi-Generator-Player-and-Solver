#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <ctime>
#include "PizzaStore.h"
using namespace std;

//Default Constructor
PizzaStore::PizzaStore(){
	name = "Core";
	maxPizzas = 3;
	productionPerTick = 2;
	successRate = 9;
	pizzas = new int[maxPizzas];
	for(int i = 0; i < maxPizzas; i++){
                pizzas[i] = 8;
        }
}

//Overloaded Constructor
PizzaStore::PizzaStore(string name, int maxPizzas, double productionPerTick, double successRate){
	srand(time(0));
	this->name = name;
	this->maxPizzas = maxPizzas;
	this->productionPerTick = productionPerTick;
	this->successRate = successRate;
	pizzas = new int[maxPizzas];
	for(int i = 0; i < maxPizzas; i++){
		pizzas[i] = 8;
	}
}

//Resets a store's pizza's all to eight
void PizzaStore::restock(){
	for(int i = 0; i < maxPizzas; i++){
                pizzas[i] = 8;
        }
}

//If a pizza is missing eight or more slices and the pizza isn't dropped (fail), then each loop sets
//one pizza currently at zero slices back up to eight and loops once or twice depending on which
//dining hall is calling the function
int PizzaStore::tickUpdate(){
	int restock = productionPerTick;
	int successfulRestock = 0;
	double fail = 0;
	while(((maxPizzas*8 - getTotalSlicesLeft()) >= 8) && restock > 0){
		for(int i = 0; i < maxPizzas; i++){
			fail = (rand()%100 + 1)/100 - successRate;
			if(pizzas[i] == 0 && fail <= 0){
				pizzas[i] = 8;
				successfulRestock++;
				i = maxPizzas;
			}
			restock--;
		}
	}
	return successfulRestock;
}

//Removes from a dining hall the passed in number of slices or returns false if it can't
bool PizzaStore::consumeSlices(int slices){
	int slicesLeft = slices;
	if(slicesLeft <= getTotalSlicesLeft()){
		for(int i = 0; i < maxPizzas; i++){
			while(pizzas[i] > 0 && slicesLeft > 0){
				pizzas[i]--;
				slicesLeft--;
			}
		}
	}
	else{
		for(int i = 0; i < maxPizzas; i++){
        	        pizzas[i] = 0;
        	}
		return false;
	}
	return true;
}

//Prints how many slices each pizza has left
void PizzaStore::showStatus(){
	cout<<setw(20)<<name<<":";
	for(int i = 0; i < maxPizzas; i++){
		cout<<" "<<pizzas[i];
	}
	cout<<endl;
}

//Gets the name of the dining hall
string PizzaStore::getName(){
	return name;
}

//Gets the total remaining slices of the dining hall
int PizzaStore::getTotalSlicesLeft(){
	int sum = 0;
	for(int i = 0; i < maxPizzas; i++){
		sum += pizzas[i];
	}
	return sum;
}

//Frees allocated memory
PizzaStore::~PizzaStore(){
	delete [] pizzas;
}

/*
Joey Benich
Date: 10/20/23
PizzaWars.cpp
Runs each week, day, and hour of the simulation
*/
#include <iostream>
#include <iomanip>
#include <string>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <unistd.h>
#include "PizzaWars.h"
#include "PizzaStore.h"
#include "Date.h"
using namespace std;

PizzaWars::PizzaWars(){}

//Prompts for the starting date of the simulation and advances to Sunday if needed
void PizzaWars::runSimulation(){
	srand(time(0));
	int d = 1;
	int m = 1;
	int y = 2000;
	cout<<"Please enter the date you'd like to start the simulation in MM DD YYYY format: ";
	cin >> m;
	cin >> d;
	cin >> y;

	Date start(m,d,y);
	Date *startPtr = &start;
	marchToSunday(startPtr);
	
	Date *week = allocateWeekOfDates(start);
	cout<<"Starting on "<<week->toString()<<endl;
	runSeriesSimulation(week,7);
	delete [] week;
}

//Creates a week of dates for the simulation to use
Date * PizzaWars::allocateWeekOfDates(Date date){
	Date *week = nullptr;
	week = new Date[7];
	week[0] = date;
	for(int i = 1; i < 7; i++){
		week[i] = ++date;
	}
	return week;
}

//Runs the simulation for each day in the week and writes the result to the log file
void PizzaWars::runSeriesSimulation(Date *dates, int length){
	PizzaStore core("Core",3,2,9);
	PizzaStore schi("Schilletter",6,1,8);
	PizzaStore *corePtr = &core;
	PizzaStore *schiPtr = &schi;
	for(int i = 0; i < length; i++){
		Date *datePtr = &dates[i];
		string winner = runDaySimulation(datePtr,corePtr,schiPtr);
		if(winner == corePtr->getName()){
			writeToFile(datePtr,corePtr);
		}
		else if(winner == schiPtr->getName()){
			writeToFile(datePtr,schiPtr);
		}
		else{
			writeToFile(datePtr,nullptr);
		}
	}
}

//Runs the simulation for each hour in the day and gives the result to runSeriesSimulation
string PizzaWars::runDaySimulation(Date *datePtr, PizzaStore *core, PizzaStore *schi){
	cout<<"\n\nRunning simulation for "<<datePtr->getDayOfWeek()<<" "<<datePtr->toString()<<"\n\n";
	string result;
	int hour = 11;
	core->restock();
	schi->restock();

	for(int i = 0; i < 20; i++){
		if((datePtr->getDayOfWeek() == "Saturday" || datePtr->getDayOfWeek() == "Sunday") && i == 18){
                	return "tie";
		}
		if(i%2 == 0){
			cout<<"\n"<<to_string(hour)<<":00\n";
		}
		else{
			cout<<"\n"<<to_string(hour)<<":30\n";
			hour++;
			if(hour == 13){
				hour = 1;
			}
		}
		result = runHourSimulation(core,schi);
		if(result != "cont"){
			return result;
		}
		usleep(50000);
	}
	return "tie";
}

//Calculates and prints the results of each hour and gives them to runDaySimulation
string PizzaWars::runHourSimulation(PizzaStore *core, PizzaStore *schi){
	int coreSlices = rand()%15+6;
        int schiSlices = rand()%15+6;
	cout<<coreSlices<<" slice(s) are consumed at Core\n";
        cout<<schiSlices<<" slice(s) are consumed at Schilletter\n";
        bool coreWin = core->consumeSlices(coreSlices);
        bool schiWin = schi->consumeSlices(schiSlices);
        core->showStatus();
        schi->showStatus();
	if(!coreWin && !schiWin){
                cout<<"TIE!\n";
		return "tie";
        }
        else if(!coreWin && schiWin){
                cout<<"Schilletter wins!\n";
		return schi->getName();
        }
        else if(!schiWin && coreWin){
		cout<<"Core wins!\n";
                return core->getName();
        }
	else{
		cout<<core->tickUpdate()<<" pizza(s) were added at Core\n";
		cout<<schi->tickUpdate()<<" pizza(s) were added at Schilletter\n";
		core->showStatus();
        	schi->showStatus();
		return "cont";
	}
}

//Advances the given date to the next valid Sunday
void PizzaWars::marchToSunday(Date* datePtr){
	if(datePtr->getDayOfWeek() != "Sunday"){
                cout<<"That day is not a Sunday, so we're moving to the nearest future Sunday to start\n";
		while(datePtr->getDayOfWeek() != "Sunday"){
			(*datePtr)++;
		}
	}
}

//Writes the result of a given day to the log.txt file
void PizzaWars::writeToFile(Date *datePtr, PizzaStore *winner){
	ofstream logFile;
	logFile.open("log.txt",ios_base::app);
	logFile<<left;
	if(winner == nullptr){
		logFile << setw(10)<<datePtr->getDayOfWeek()<<setw(10)<<datePtr->toString()<<"Tie!"<<endl;
	}
	else{
		logFile << setw(10)<<datePtr->getDayOfWeek()<<setw(10)<<datePtr->toString()<<winner->getName()<<" won with "<<winner->getTotalSlicesLeft()<<" slices left!"<<endl;
	}
	logFile.close();
}

/*
Joey Benich
Date: 10/20/23
Date.cpp
Creates and manipulates dates
*/
#include <iostream>
#include <string>
#include "Date.h"
#include "MysteryMachine.h"
using namespace std;

//Default Constructor
Date::Date(){
	month = 1;
	day = 1;
	year = 2000;
}

//Overloaded Constructor
Date::Date(int month, int day, int year){
	this->month = month;
	this->day = day;
	this->year = year;
}

//Gets the month
int Date::getMonth(){
	return month;
}

//Gets the day
int Date::getDay(){
        return day;
}

//Gets the year
int Date::getYear(){
        return year;
}

//Sets the month
void Date::setMonth(int month){
        this->month = month;
}

//Sets the day
void Date::setDay(int day){
        this->day = day;
}

//Sets the year
void Date::setYear(int year){
        this->year = year;
}

//Increases the day by an int
Date Date::operator+(int days){
	while(days > 0){
		switch(month){
			case 1: case 3: case 5:	case 7:	case 8:	case 10: case 12:
				if(day < 31){
		      			day++;
				}
				else{
					day = 1;
					if(month < 12){
						month++;
					}
					else{
						month = 1;
						year++;
					}
				}
				days--;
			break;
			default:
				if(day < 30){
                                        day++;
                                }
                                else{
                                        day = 1;
                                        if(month < 12){
                                                month++;
                                        }
                                        else{
                                                month = 1;
                                                year++;
                                        }
                                }
                                days--;
		}
	}
	Date newDate(month,day,year);
	return newDate;
}

//Decreases the day by an int
Date Date::operator-(int days){
        while(days > 0){
                switch(month){
			case 2: case 4: case 6: case 8: case 9: case 11: case 1:
                                if(day > 1){
                                        day--;
                                }
                                else{
                                        day = 31;
                                        if(month > 1){
                                                month--;
                                        }
                                        else{
                                                month = 12;
                                                year--;
                                        }
                                }
                                days--;
                        break;
                        default:
                                if(day > 1){
                                        day--;
                                }
                                else{
                                        day = 30;
                                        if(month > 1){
                                                month--;
                                        }
                                        else{
                                                month = 12;
                                                year--;
                                        }
                                }
                                days--;
                }
        }
        Date newDate(month,day,year);
        return newDate;
}

//Increases day by one and returns it
Date Date::operator++(void){
        switch(month){
		case 1: case 3: case 5: case 7: case 8: case 10: case 12:
                        if(day < 31){
                                day++;
                        }
                        else{
                                day = 1;
                                if(month < 12){
                                        month++;
                                }
                                else{
                                        month = 1;
                                        year++;
                                }
                        }
                break;
                default:
                        if(day < 30){
                                day++;
                        }
                        else{
                                day = 1;
                                if(month < 12){
                                        month++;
                                }
                                else{
                                        month = 1;
                                        year++;
                                }
                        }
        }
	Date newDate(month,day,year);
        return newDate;
}

//Increases day by one and returns the original day
Date Date::operator++(int){
        Date newDate(month,day,year);
	switch(month){
		case 1: case 3: case 5: case 7: case 8: case 10: case 12:
                        if(day < 31){
                                day++;
                        }
                        else{
                                day = 1;
                                if(month < 12){
                                        month++;
                                }
                                else{
                                        month = 1;
                                        year++;
                                }
                        }
                break;
                default:
                        if(day < 30){
                                day++;
                        }
                        else{
                                day = 1;
                                if(month < 12){
                                        month++;
                                }
                                else{
                                        month = 1;
                                        year++;
                                }
                        }
        }
        return newDate;
}

//Decreases the day by one and returns it
Date Date::operator--(void){
	switch(month){
		case 2: case 4: case 6: case 8: case 9: case 11: case 1:
                	if(day > 1){
                		day--;
                        }
                        else{
                                day = 31;
                                if(month > 1){
                        		month--;
                                }
                                else{
                                        month = 12;
                                        year--;
                                }
                        }
		break;
                default:
                        if(day > 1){
                                day--;
                        }
                        else{
                                day = 30;
                                if(month > 1){
                                        month--;
                                }
                                else{
                                        month = 12;
                                        year--;
                                }
                        }
	}
	Date newDate(month,day,year);
        return newDate;
}

//Decreases the day by one and returns the original
Date Date::operator--(int){
        Date newDate(month,day,year);
	switch(month){
		case 2: case 4: case 6: case 8: case 9: case 11: case 1:
                        if(day > 1){
                                day--;
                        }
                        else{
                                day = 31;
                                if(month > 1){
                                        month--;
                                }
                                else{
                                        month = 12;
                                        year--;
                                }
                        }
                break;
                default:
                        if(day > 1){
                                day--;
                        }
                        else{
                                day = 30;
                                if(month > 1){
                                        month--;
                                }
                                else{
                                        month = 12;
                                        year--;
                                }
                        }
        }
        return newDate;
}

//Returns the day of the week
string Date::getDayOfWeek(){
	Date newDate(month,day,year);
	MysteryMachine stringDate;
	return stringDate.getDayOfWeek(newDate);
}

//Returns the date in form mm/dd/yyyy
string Date::toString(){
	string slash = "/";
        return to_string(month)+slash+to_string(day)+slash+to_string(year);
}